# Be awayre this code was mainly generated by an LLM!

import argparse
import os
import subprocess
import sys
import tempfile
from pathlib import Path


def sync_files_to_target(source: Path, target: Path, files_to_sync: Path) -> None:
    print("Sync files")
    os.chdir(source)
    subprocess.run(
        [
            "rsync",
            "--recursive",
            "--relative",
            "--info=NAME1",
            f"--files-from={files_to_sync}",
            ".",
            str(target),
        ],
        check=True,
    )


def create_list_of_album_directories(
    files_to_sync: Path,
    album_directories: Path,
) -> None:
    print("Create list of album directories")
    seen: set[str] = set()
    with (
        Path.open(files_to_sync, "r", encoding="utf-8") as input_files,
        Path.open(album_directories, "w", encoding="utf-8") as output_directory,
    ):
        for file in input_files:
            striped_file = file.rstrip("\n")
            dirname = str(Path(striped_file).parent)
            if dirname not in seen:
                output_directory.write(f"{dirname}\n")
                seen.add(dirname)
    # Sort and remove duplicates
    sort_and_dedup(album_directories)


def append_cover_art_paths(
    source: Path,
    album_directories: Path,
    files_to_sync: Path,
) -> None:
    print("Append cover art paths")
    cover_files: set[str] = set()
    with Path.open(album_directories, "r", encoding="utf-8") as album_f:
        for line in album_f:
            album_dir = line.rstrip("\n")
            full_album_path = source / album_dir
            if not full_album_path.is_dir():
                continue
            for file in full_album_path.glob("cover.*"):
                rel_path = f"./{os.path.relpath(file, source)}"
                cover_files.add(rel_path)
    if cover_files:
        with Path.open(files_to_sync, "a", encoding="utf-8") as f:
            for cover_path in sorted(cover_files):
                f.write(f"{cover_path}\n")
    sort_and_dedup(files_to_sync)


def convert_playlist_to_syncable_paths(
    source: Path,
    playlist: Path,
    files_to_sync: Path,
) -> None:
    print("Convert playlist")
    with (
        Path.open(playlist, "r", encoding="utf-8") as pl_f,
        Path.open(files_to_sync, "w", encoding="utf-8") as sync_f,
    ):
        for line in pl_f:
            s = line.strip()
            if not s or s.startswith("#"):
                continue
            # Normalize path
            abs_source_str = str(source)
            if s.startswith(abs_source_str):
                relative = "./" + s[len(abs_source_str) :].lstrip("/")
            else:
                relative = s
            sync_f.write(f"{relative}\n")


def find_all_files_in_target(target: Path, all_files_in_target: Path) -> None:
    print("Get all files in target")
    files: list[str] = []
    for root, _, files_in_dir in os.walk(target):
        for fn in files_in_dir:
            full_path = Path(root) / fn
            rel_path = f".{os.sep}{os.path.relpath(full_path, target)}"
            files.append(rel_path)
    files.sort()
    with Path.open(all_files_in_target, "w", encoding="utf-8") as f:
        for path in files:
            f.write(f"{path}\n")


def remove_surplus_files(
    target: Path,
    all_files_in_target: Path,
    files_to_sync: Path,
) -> None:
    print("Removing surplus files.")
    with (
        Path.open(all_files_in_target, "r", encoding="utf-8") as existing_files,
        Path.open(files_to_sync, "r", encoding="utf-8") as files_to_process,
    ):
        all_files_set = {file.rstrip("\n") for file in existing_files}
        playlist_set = {file.rstrip("\n") for file in files_to_process}
        surplus_files = sorted(all_files_set - playlist_set)
    for rel_path in surplus_files:
        full_path = (
            target / rel_path[2:] if rel_path.startswith("./") else target / rel_path
        )
        print(f"Removing: {rel_path}")
        full_path.unlink()
    print("Cleaning empty directories")
    for root, dirs, _ in os.walk(target, topdown=False):
        for d in dirs:
            dir_path = Path(root) / d
            dir_path.rmdir()


def sort_and_dedup(path: Path) -> None:
    lines: set[str] = set()
    with Path.open(path, "r", encoding="utf-8") as f:
        for line in f:
            lines.add(line.rstrip("\n"))
    with Path.open(path, "w", encoding="utf-8") as f:
        for line in sorted(lines):
            f.write(f"{line}\n")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Sync playlist files and cover art to target location",
    )
    parser.add_argument(
        "playlist",
        type=Path,
        help="Path to playlist file",
    )
    parser.add_argument(
        "destination",
        type=Path,
        help="Top-level destination directory (will sync to <destination>/synced)",
    )
    parser.add_argument(
        "--source",
        type=Path,
        default=Path("/mnt/media/"),
        help="Source directory (default: /mnt/media/)",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    playlist: Path = args.playlist.resolve()
    source: Path = args.source.resolve()
    target: Path = (args.destination / "synced").resolve()

    Path.mkdir(target, exist_ok=True)

    with tempfile.TemporaryDirectory() as tmpdir:
        tmp_path = Path(tmpdir)
        album_directories: Path = tmp_path / "album_directories.txt"
        all_files_in_target: Path = tmp_path / "all_files_in_target.txt"
        files_to_sync: Path = tmp_path / "files_to_sync.txt"

        convert_playlist_to_syncable_paths(source, playlist, files_to_sync)
        create_list_of_album_directories(files_to_sync, album_directories)
        append_cover_art_paths(source, album_directories, files_to_sync)
        sync_files_to_target(source, target, files_to_sync)
        find_all_files_in_target(target, all_files_in_target)
        remove_surplus_files(target, all_files_in_target, files_to_sync)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)
